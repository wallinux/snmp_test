/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.int_watch.conf,v 5.0 2002/04/20 07:30:13 hardaker Exp $
 * But it's been hacked around a LOT since then!
 * This is a test AgentX subagent implementing a dummy (and sorely incomplete)
 * Linux MD-RAID status MIB using a single table within the NET-SNMP Tutorial
 * MIB Area.  It is intended to demonstrate exercising a bug in the AgentX
 * disconnect code in snmpd.
 * Since it is only a demo, the RAID information is taken from a static table
 * should a full implementation be required, the job of dragging the relevant
 * stats out of /sys/block/md[0-n]/md is left to the reader.....
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "subagentObject.h"

/* Prototype of access function (forward declaration) */
char *findTestTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method);

/* MIB to be registered */

static const struct variable2 TestTable[] =
{
{ MAGIC_ENTRY , ASN_INTEGER, RONLY, (FindVarMethod *)&findTestTable, 2 , {1,1} }, /* testTableNtry (Index) */
{ MAGIC_DEV , ASN_OCTET_STR , RONLY, (FindVarMethod *)&findTestTable, 2 , {1,2} }, /*testTableDev */
{ MAGIC_LEVEL , ASN_OCTET_STR , RONLY, (FindVarMethod *)&findTestTable, 2 , {1,3} }, /*testTableLevel */
{ MAGIC_NUMDEV , ASN_INTEGER , RONLY, (FindVarMethod *)&findTestTable, 2 , {1,4} }, /*testTableNumDev */
{ MAGIC_STATUS , ASN_INTEGER , RONLY, (FindVarMethod *)&findTestTable, 2 , {1,5} } /*testTableStatus */
};

/* Dummy data to be returned */

static const struct TestTableEntry TestData[] =
{
  { "/dev/md0", "raid1", 2, 1 },
  { "/dev/md1", "raid1", 2, 1 },
  { "/dev/md2", "raid5", 4, 1 },
  { "/dev/md4", "raid5", 4, 1 }
};

/* How many disks in the table */
static const int NumTestDisks = 4;
/* Where the index value lives in the OID */
static size_t DiskTableIndexPos = 12;

/*
 * our initialization routine, automatically called by the agent 
 * (to get called, the function name must match init_FILENAME()) 
 */
void
init_nstAgentSubagentObject(void)
{
    static oid      nstAgentSubagentTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 8072, 2, 5, 1 };
    static size_t nstAgentSubagentTable_oid_len = 10;

    /*
     * a debugging statement.  Run the agent with -DnstAgentSubagentObject to see
     * the output of this debugging statement. 
     */
    DEBUGMSGTL(("nstAgentSubagentObject",
                "Initializing the nstAgentSubagentObject module\n"));

    DEBUGMSGTL(("nstAgentSubagentObject",
                "Initalizing nstAgentSubagentObject Test Table\n"
                ));

    if(register_mib("testTable",(struct variable *)TestTable,
		sizeof(struct variable2),
		sizeof(TestTable)/ sizeof(struct variable2),
		nstAgentSubagentTable_oid,nstAgentSubagentTable_oid_len)
		!=SNMPERR_SUCCESS)
    {
	DEBUGMSGTL(("nstAgentSubagentObject",
		"register_mib failed - giving up...\n"));
		exit(1);
    }

    DEBUGMSGTL(("nstAgentSubagentObject",
                "Done initalizing nstAgentSubagentObject module\n"));
}

char *findTestTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
{
	/* foundit >=0 if full or partial OID match...*/
	int i,foundit = -1;

	/* SNMP_GET is difficult enough, let's leave SET alone */
	*write_method = NULL;

	DEBUGMSGTL(("nstAgentSubagentObject","exact is %d",exact));
	DEBUGMSGOID(("nstAgentSubagentObject",vp->name,vp->namelen)); 
	
	/* Loop though the disk array */
	for (i=0; i<NumTestDisks; i++)
	{
		oid newname[MAX_OID_LEN];

		/* form a candidate OID */
		memcpy( (char *)newname, (char *)vp->name, vp->namelen * sizeof(oid));
		newname[DiskTableIndexPos]=i+1;

		/* Does it match */
		int result = snmp_oid_compare(name, *length, newname, (int)vp->namelen + 1);

		if ( (exact && (result == 0)) || (!exact &&( result < 0)))
		{
			/* Candidate match, lets keep hold of it */
			foundit=i;
			memcpy( (char *) name, (char *) newname, ((int)vp->namelen + 1) *sizeof(oid));
			*length = vp->namelen+1;
			break; 
		}
	}

	/* did we actually match anything? */
	if (foundit>=0)
	{
		/* Work out which value we want to return */
		switch(vp->magic)
		{
			case MAGIC_ENTRY:
				long_return=foundit+1;
				*var_len = sizeof(long_return);
				return((char *)&long_return);

			case MAGIC_DEV:
				strncpy(return_buf,TestData[foundit].dev,MAXSTRLEN);
				return_buf[MAXSTRLEN-1]='\0';
				*var_len=strlen(return_buf);
				return(return_buf);
				
			case MAGIC_LEVEL:
				strncpy(return_buf,TestData[foundit].level,MAXSTRLEN);
				return_buf[MAXSTRLEN-1]='\0';
				*var_len=strlen(return_buf);
				return(return_buf);
			
			case MAGIC_NUMDEV:
				long_return=TestData[foundit].numdev;
				*var_len = sizeof(long_return);
				return((char *)&long_return);
			
			case MAGIC_STATUS:
				long_return=TestData[foundit].status;
				*var_len = sizeof(long_return);
				return((char *)&long_return);

			default:
				/* Unrecognised! */
				return(NULL);
		}

	}

	/* nothing found ...*/
	return (NULL);

}
